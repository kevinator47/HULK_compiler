\documentclass[11pt, a4paper, twoside]{article} % o book si es muy extenso
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern} % Fuente moderna y legible
\usepackage{microtype} % Mejora el espaciado y la justificación
\usepackage{geometry} % Para controlar los márgenes
    \geometry{
        a4paper,
        top=2.5cm,
        bottom=2.5cm,
        left=3cm,
        right=2.5cm,
        headheight=14pt,
        footskip=1.2cm
    }
\usepackage{fancyhdr} % Para personalizar encabezados y pies de página
\usepackage{graphicx} % Para incluir imágenes
\usepackage{hyperref} % Para enlaces interactivos y metadatos
    \hypersetup{
        colorlinks=true,
        linkcolor=blue,
        filecolor=magenta,
        urlcolor=cyan,
        pdftitle={Título de tu Proyecto},
        pdfauthor={Tu Nombre},
        pdfsubject={Informe de Proyecto Escolar},
        pdfkeywords={Proyecto, Escuela, Informe, LaTeX},
        bookmarks=true,
        bookmarksopen=true,
        bookmarksnumbered=true,
    }
\usepackage{titlesec} % Para personalizar títulos de secciones
\usepackage{enumitem} % Para personalizar listas
\usepackage{setspace} % Para controlar el interlineado
    \onehalfspacing % Interlineado de 1.5 para mejor lectura
\usepackage{listings}
\usepackage{xcolor} % Asegúrate de tenerlo para los colores

% --- Configuración de listings para código ---
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize, % Fuente monoespaciada, tamaño pequeño
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left, % Números de línea a la izquierda
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2, % Tamaño de la tabulación
    frame=single, % Marco alrededor del código
    rulecolor=\color{black},
    frameround=tttt, % Esquinas redondeadas
    extendedchars=true, % Para caracteres extendidos (como 'ñ')
    literate={á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1 {ñ}{{\~n}}1 % Para manejar tildes y eñes
}

\lstset{style=mystyle} % Aplicar el estilo por defecto
\usepackage{lastpage} % Para obtener el número total de páginas

% --- Personalización de títulos de secciones ---
\titleformat{\section}[block]
  {\normalfont\Large\bfseries\color{green!70!black}}
  {\thesection}{1em}{}
\titlespacing*{\section}
  {0pt}{1.5ex plus .1ex minus .2ex}{1ex plus .1ex}

\titleformat{\subsection}[block]
  {\normalfont\large\bfseries\color{blue!50!black}}
  {\thesubsection}{1em}{}
\titlespacing*{\subsection}
  {0pt}{1.5ex plus .1ex minus .2ex}{1ex plus .1ex}

% --- Configuración de encabezados y pies de página ---
\pagestyle{fancy}
\fancyhf{} % Borra los ajustes predeterminados
\fancyhead[RO,LE]{\thepage} % Número de página a la derecha en páginas impares, a la izquierda en pares
\fancyhead[LO]{\nouppercase{\rightmark}} % Título de la sección en la parte izquierda (páginas impares)
\fancyhead[RE]{\nouppercase{\leftmark}} % Título del capítulo en la parte derecha (páginas pares) (si usas 'book' o 'report')
\fancyfoot[C]{\textbf{Informe de Proyecto}} % Texto en el pie de página centrado
\renewcommand{\headrulewidth}{0.4pt} % Línea en el encabezado
\renewcommand{\footrulewidth}{0.4pt} % Línea en el pie de página

\begin{document}

\thispagestyle{empty} % Para que la primera página no tenga encabezado ni pie de página

\begin{titlepage}
    \begin{center}
        % --- Espacio superior ---
        \vspace*{2cm}

        % --- Logo del proyecto ---
        \includegraphics[width=0.3\textwidth]{logo.png} % Ajusta el tamaño según tu logo
        \vspace{1cm}

        % --- Título del Proyecto ---
        {\color{green!80!black}\Huge\bfseries Compilador de HULK}\par
        \vspace{0.5cm}

        % --- Subtítulo (opcional) ---
        {\color{gray}\Large\itshape Un informe detallado sobre la implementaci\'on de un Compilador para el lenguaje HULK}\par
        \vspace{2cm}

        % --- Integrantes del Equipo ---
        {\Large\bfseries Integrantes:}\par
        \vspace{0.3cm} % Espacio entre "Integrantes:" y los nombres
        {\large  Kevin Marqu\'ez Vega}\par
        {\large  Javier Alejandro Gonz\'ales}\par
        {\large  Jos\'e Miguel Leyva}\par
        \vspace{1.5cm} % Espacio después de los nombres

        % --- Información del Curso/Asignatura ---
        {\large Asignatura: Compilaci\'on}\par
        {\large Universidad de La Habana}\par
        \vspace{0.5cm}

        % --- Fecha ---
        {\large \today}\par % Muestra la fecha actual
        \vfill % Empuja el contenido restante hacia abajo

        % --- Información adicional (opcional, por ejemplo, el semestre) ---
        {\small \color{gray!70!black} Semestre: Segundo Semestre | Tercer a\~no}\par

    \end{center}
\end{titlepage}

\clearpage
% ... (el resto de tu documento sigue aquí, como la tabla de contenido y las secciones)

\clearpage % Para empezar el contenido en una nueva página
% Aquí puedes incluir tu tabla de contenido, si la necesitas:
% \tableofcontents
% \clearpage

% --- Comienza el contenido de tu informe ---
\section{Introducción}
Para la aplicaci\'on de los conocimientos adquiridos en la asignatura de Compilaci\'on, se llev'o a cabo
la implementaci\'on y desarrollo de un compilador para el lenguaje HULK (Havana University Language for Kompilers)
utilizando \textbf{C} como lenguaje base.

El compilador se divide en 4 etapas fundamentales: An\'alisis l\'exico \textit{lexer}, An\'alisis sint\'actico \textit{parser}.
An\'alisis sem\'antico y Generaci\'on de c\'odigo. Cada etapa ser\'a explicada detalladamente en el presente informe.

\subsection{Flujo del Programa}
El flujo del programa sigue el camino de cualquier compilador est\'andar. Comienza en la funci\'on \textit{main()} dentro del script
\textbf{main.c} la cual se encarga de leer el contenido del archivo \textbf{script.hulk} convirtiendo el mismo cadena de texto. Dicha 
cadena es enviada al \textit{lexer} y \textit{parser} para los an\'alsis l\'exico y sint\'actico respectivamente. Si no ocurre ning\'un
error en las etapas descritas se generar\'a el \'Arbol de Sintaxis Abstracta (AST por sus siglas en ingl\'es). Posteriormente se comienza el
Chequeo Sem\'antico de las expresiones definidas en el archivo \textit{.hulk} y finalmente se llega a la etapa de Generaci\'on de C\'odigo,
en la cual se mostrar\'an los resultados de compilar un script del lenguaje HULK en un archivo generado llamado \textbf{output.ll} en 
la carpeta \textbf{build}.

\section{An\'alisis L\'exico: Lexer}
Para el an\'alisis l\'exico de cualquier lenguaje se necesitan, entre otras cosas, una definici\'on de \textbf{Token}. Un Token
es una cadena de car\'acteres que representa un s\'imbolo que se utiliza en el lenguaje, ejemplo : palabras claves, operadores, variables etc.
Se hizo un estudio a fondo del lenguaje \textbf{HULK} para obtener todos los tokens del mismo y preparar todo para comenzar el an\'alisis.

El lexer utilizado es el brindado por la librer\'ia \textit{Flex}, el cual es muy robusto y completo, facilitando el desarrollo
de esta etapa de la compilaci\'on. Dentro del mismo se definen las principales expresiones regulares que intervienen en el lengujae,
as\'i como la representaci\'on en string de cada token con su correspondiente valor de retorno.

\textit{Flex} proporciona un generador de lexer, el cual, conociendo las expresiones regulares que intervienen en el lenguaje, y una secuencia de
car\'acteres determina los tokens que participan en dicha cadena y los deja listos para el an\'alisis sint\'actico.

\section{An\'alisis Sint\'actico: Parser}
En el An\'alisis sint\'actico se hizo con el framework proporcionado por \textbf{Yacc}, el cual al obtener la gram\'atica, bien definida, 
crea un AST en funci\'on del conjunto de expresiones que se utilizaron en el programa Hulk. 

\subsection{La gram\'atica}
La definici\'on de la gramatica la puede encontrar en el archivo \texttt{parser.y} en la que se ve claramente las producciones. Debido a la comletitud
y complejidad del lenguaje se hizo necesario definir una gram\'atica que no fuera \textbf{LL1} para que todas las operaciones que intervienen en las expresiones
sean analizadas correctamente tanto por las tres primeras etapas como por la generaci\'on de c\'odigo intermedio.

\subsection{AST}
El AST es una parte fundamental del desarrollo de compiladores, por lo que se hizo necesario poder modelar el comportamiento del mismo. Como en el lenguaje C no
existe la programaci\'on orientada a objetos, es muy complicado simular la herencia y las clases abstractas, ambos conceptos facilitan la implementaci\'on y 
lectura de c\'odigo cuando se trata de estructuras arboreas.

Para representar el AST se defini\'o un nodo por cada tipo de expresi\'on definida en la gram\a'tica del lenguaje ejemplo: \texttt{LetInNode}, \texttt{FunctionDefinitionNode}, 
\texttt{LiteralNode} etc. Adem\'as con el objetivo de simular la herencia, cada nodo tiene entre sus propiedades un struct de tipo \textbf{ASTNode}, el cual contiene
todos los atributos que comparten los nodos del AST, como el tipo y el valor de retorno.

\begin{figure}[h!] 
    \centering
    \includegraphics[width=0.8\textwidth]{ASTNode.png}
    \caption{Estructura de ASTNode} 
\end{figure}

\subsection{Flujo de Yacc}
Una vez definida la gram\'atica y el formato que tendr\'an los nodos del AST, se puede empezar a explicar el flujo de trabajo de Yacc. En el programa 
en C se tiene una funci\'on de creaci\'on por cada uno de los nodos anteriormente definidos. Dichas funciones son asociadas a las reglas de la gram\'atica
de esta forma se va construyendo el AST, dejando siempre como ra\'iz un nodo del tipo \texttt{ProgramNode} a partir del cual iniciar\'an los procesos que quedan.

\begin{figure}[h!] 
    \centering 
    \includegraphics[width=0.8\textwidth]{CreacionAST.png}
    \caption{Algunos ejemplos de llamadas en funciones desde Yacc} 
\end{figure}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{ProgramNode.png}
    \caption{Estructura de ASTNode}
\end{figure}

\section{Chqueo Sem\'antico}
A partir de este momento comienza el chequeo sem\'antico, el cual est\'a implementado sin usar librer\'ias, bas\'andose en la definici\'on de nodos de AST mostrada
anteriormente. Se hace uso del \textbf{Patr\'on Visitor} para realizar esta tarea. El idea es hacer varios recorridos por el AST Generado dividiendo el trabajo en
varias etapas. La primera ser\'a para capturar todas las definiciones de funciones y creaci\'on de variables que se hallan realizado, la segunda para las definiciones 
de tipos y sus propiedades y finalmente para ver si el uso de las variables dentro de operaciones o funciones es el correcto de acuerdo a su tipo.

El compilador se pens\'o para la versi\'on de HULK de tipado est\'atico, \textit{Type-HULK} es decir, tanto para la definici\'on de funciones como para la de tipos
es necesario definir el tipo de cada uno de los par\'ametros. Esto ayuda en el momento de inferir el tipo de retorno de las funciones y ayuda a que no se hagan llamadas 
con los par\'ametros incorrectos, como por ejemplo \texttt{Factorial("5")}. 

Para llevar a cabo esta tarea, se definieron numerosas estructuras en C para manejar los contextos. Se tiene la struct \texttt{Symbol}, la cual se usa
para guardar todas las propiedades referidas al uso de variables y llamado de funciones. Una struct con el nombre de \texttt{SymbolTable}, que representa el contexto,
dicha tabla guarda la informaci\'on de todas aquellas variables y funciones que fueron definida en un contexto determinado. 

\subsection{Primera Etapa: Funciones}
Como se mencion\'o anteriormente en esta etapa se busca capturar todas las definciones de funciones que se realizaron en el script de HULK. Basicamente se recorre cada nodo
del AST hasta encontrar un \textbf{FunctionDefinitionNode}. Aclarar que en el lenguaje HULK no se pueden definir funciones dentro de otras funciones ni dentro de cualquier otro
nodo que implique la creaci\'on de un bloque de expresiones, por lo que este recorrido es posible y basta con analizar la \"Capa Superior\" del script.
Una vez encontradas todas las funciones se guardan en el Contexto global, permitiendo acceder a ellas desde cualquier punto del script de HULK.

\subsection{Segunda Etapa: Tipos}
Una vez guardadas todas las funciones en el Contexto global, se procede de manera similar para el analisis de tipo. Dentro de cada tipo se definir\'a un nuevo contexto, 
debido a que dentro del cuerpo de un tipo pueden existir propiedades y funciones, por tanto se guardan en un contexto propio que tienen los tipos nuevos definidos. 

\subsection{Tercera Etapa: Visita Sem\'antica}
Se implement\'o un struct \textbf{TypeDescriptor} en C para poder tener control de los tipos que intervienen en el lenguaje HULK as\'i como los tipos definidos por el usuario,
para estos \'ultimos se defini\'o la struct \textbf{TypeInfo}. El patr\'on visitor lo que har\'a es entrar en cada nodo del AST, los cuales tienen su propia forma de chequearse
e ir\'a retornando los TypeDescriptors correspondientes.

\begin{figure}[h!] 
    \centering 
    \includegraphics[width=0.8\textwidth]{Types.png}
    \caption{Type Descriptor y TypeInfo}
\end{figure}

\subsection{Declaraci\'on y uso de Variables}
Al declararse una variable en un programa de HULK, como bien se explic\'o anteriormente, se crea el s\'imbolo correspondiente y se guarda en el contexto en donde fue creada 
junto con su valor asignado. Si se encuentra el uso de la variable en alg\'un posterior a su definicio\'on, se chequea primera si en el contexto existe ya esa variable definida,
en HULK se pueden definir dos variables con el mismo nombre, al usar una dentro de un contexto, esta tomar\'a como valor el \'ultimo que se le asign\'o dentro del contexto actual,
o en un contexto superior. 

El patr\'on visitor, al llegar a una expresi\'on que indique el uso de una variable, deber\'a realizar las siguientes acciones: Chequear si dicha variable fue definida en el 
contexto actual o en uno superior y posteriormente analizar si su uso es correcto debido a su tipo de retorno.\\

\begin{lstlisting}[language=Go]
  let a = 10 in
    if (a >= 0)
    {
      print(a + 5);
    }
    else
    {
      let a = 11 in print(a);
    }
\end{lstlisting}

\subsection{Definici\'on y llamado de Funciones}
Las funciones siempre ser\'an definidas en el Contexto global del programa, como se explic\'o anteriormente, el tipado es est\'atico por lo que se debe especificar el tipo de cada 
par\'ametro de las funciones para poder declararlas. Como esto se conoce, es m\'as f\'acil determinar si las operaciones que se realizan dentro del cuerpo de una funci\'on 
tienen sem\'antica correcta.

Respecto al llamado de funciones, es sabido que en el HULK el tipo de retorno de una funci\'on es el mismo que el de su cuerpo, como el cuerpo de una funci\'on
puede ser un bloque de expresiones, entonces el tipo de retorno de una funci\'on es el de la \'ultima expresi\'on de su cuerpo. De esa forma al hacer algo como:\\

\begin{lstlisting}[language=Go]
function Sucesor(n : Number) => n + 1;
let a : Number = 3 in print(Square(a) + 4);
\end{lstlisting}

No ocurrir\'a ning\'un error sem\'antico, debido a que se especifica el tipo de dato del parametro \texttt{n} y es f\'acil determinar que la expresi\'on
\texttt{n + 1} es sem\'anticamente correcta y devuelve un tipo Number.

\subsection{Definici\'on de tipos y acceso a propiedades}
HULK es lenguaje con POO, por tanto se puede definir tipos nuevos en cualquier momento y utilizarlos en el programa. Al igual que en los tipos
b\'asicos del lenguaje, la informaci\'on de los tipos creados por el usuario se guardan en un \textbf{TypeDescriptor}. Sin embargo en esta ocasi\'on
la propiedad \textbf{TypeInfo} deja de ser Null, ya que este tipo fue definido por el propio usuario.

Al ser pensado para la versi\'on de tipado est\'atico, como mismo ocurre en las funciones, en este caso se deben definir los tipos que tendr\'an los 
par\'ametros que recibe la funci\'on constructor del nuevo tipo definido por el usuario.  Una vez m\'as, esto ayuda a la hora de realizar el chequeo 
sem\'antico de cada funci\'on o propiedad que se define en un objeto. 

\subsubsection{Herencia}
La herencia tambi\'en es una de las tantas posibilidades que permite el lenguaje Hulk, posibilidad que tambi\'en es manejada por el compilador. Cada tipo
tiene en su \texttt{TypeDescriptor} una propiedad con el nombre de \texttt{parent}, la cual hace referencia a un posible objeto padre del objeto en cuesti\'on.
El padre por defecto definido por el compilador de todos los tipos, incluidos los tipos definidos por el lenguaje es \textbf{Object}, de esta manera, se logra 
tener una condici\'on de parada para el algoritmo de b\'usqueda de los padres. El algoritmo es similar a un DFS, si se tiene un tipo A, y accede a una propiedad
mediante la notaci\'n \texttt{A.prop()} si la propiedad est\'a en la definici\'on del tipo A, entonces se continua con el cheuqeo del programa,
en caso contrario se busca la definici\'on del tipo A y se hace una b\'usqueda de sus padres de manera recursiva, hasta llegar al tipo \textbf{Object} o hasta
llegar a alg\'un ancestro que contenga la propiedad. 


\subsubsection{Herencia Circular}
Esto no est\'a permitido en el lenguaje, por tanto en el momento de definir un tipo nuevo, si este hereda de alg\'un tipo, se debe realizar una b\'usqueda de
los ancestros de manera recursiva, si se llega al tipo actual, entonces es evidencia de la existencia de un ciclo en la herencia, por tanto se debe lanzar un 
error. Note que el algoritmo es el mismo en ambos casos, por eso se opt\'o por reutilizar el mismo c\'odigo para la realizaci\'on de las dos tareas.

\section{Generación de Código LLVM}

La generación de código intermedio en el compilador \textbf{Hulk} se realiza utilizando \textbf{LLVM IR} (Intermediate Representation), que permite producir una representación de bajo nivel optimizable y portable del programa fuente.

\subsection{Componentes Principales}

En esta sección se describen las estructuras fundamentales de LLVM utilizadas para generar código.

\begin{itemize}
    \item \textbf{LLVMContext}: Encapsula información global como tipos y constantes.
    \item \textbf{LLVMModule}: Representa el programa completo como una unidad LLVM.
    \item \textbf{LLVMBuilder}: Se encarga de insertar instrucciones en bloques básicos.
\end{itemize}

\subsection{Estructura del Generador}

A continuación se detallan los elementos que conforman la estructura principal del generador de código, encargados de mantener estado durante la traducción del AST.

\begin{itemize}
    \item Contexto, módulo y builder de LLVM.
    \item Tabla de tipos global (\texttt{TypeTable}).
    \item Pilas de ámbitos para tipos y variables (\texttt{TypeScopeStack}, \texttt{ScopeStack}).
    \item Funciones de visita para cada tipo de nodo del AST, aplicando el patrón \textit{Visitor}.
\end{itemize}

\subsection{Flujo General de Generación}

Esta sección resume el flujo completo de la generación de código, desde la preparación del entorno hasta la verificación final del módulo LLVM.

\begin{enumerate}
    \item \textbf{Inicialización}: Se crean las estructuras de base necesarias y se declaran elementos externos.
    \begin{itemize}
        \item Se declaran funciones externas como \texttt{printf}, \texttt{malloc}, \texttt{sqrt}, etc.
        \item Se registran tipos definidos por el usuario como estructuras LLVM.
        \item Se declaran las firmas de todas las funciones y métodos definidos por el usuario.
    \end{itemize}
    
    \item \textbf{Traducción del AST}: Se recorren los nodos del árbol sintáctico y se generan instrucciones LLVM correspondientes.
    \begin{itemize}
        \item Se construyen los cuerpos de las funciones definidas por el usuario.
        \item Se traduce el nodo raíz del programa, generando el contenido del \texttt{main}.
    \end{itemize}
    
    \item \textbf{Gestión de Ámbitos}: Se administra el almacenamiento de variables y su visibilidad a través de estructuras de pila.
    \begin{itemize}
        \item Se utiliza una pila de \texttt{IrSymbolTable} para almacenar variables y soportar scopes anidados.
        \item Cada símbolo contiene un \texttt{LLVMValueRef} que referencia su alocación en memoria.
    \end{itemize}
    
    \item \textbf{Verificación}: Se garantiza que el IR generado sea válido y esté libre de errores estructurales.
    \begin{itemize}
        \item Al finalizar, se valida el módulo con \texttt{LLVMVerifyModule} para detectar errores en el IR.
    \end{itemize}
\end{enumerate}

\subsection{Ejemplo de Traducción}

Este ejemplo ilustra cómo una sentencia simple se transforma en instrucciones LLVM:

Una sentencia como \texttt{let x = 5.0} se transforma en:

\begin{enumerate}
    \item Creación de una instrucción \texttt{alloca} para \texttt{x}.
    \item Inserción de una instrucción \texttt{store} para guardar el valor \texttt{5.0}.
    \item Registro del símbolo \texttt{x} en la tabla de símbolos actual.
\end{enumerate}

\section{Manejo de Errores}

El manejo de errores en el compilador \textbf{Hulk} está diseñado para proporcionar mensajes útiles y precisos durante las distintas fases del análisis y la generación de código. A continuación se describe cómo se gestionan los errores en cada etapa del proceso de compilación.

\subsection{Errores Léxicos (Lexer con Flex)}

Durante el análisis léxico, el analizador construido con \textbf{Flex} identifica patrones de texto y los convierte en tokens. El manejo de errores léxicos se realiza cuando se detectan caracteres no válidos o secuencias inesperadas.

\begin{itemize}
    \item Se define una regla de ``fallback'' en el lexer para capturar cualquier carácter no reconocido.
    \item Se imprime un mensaje de error indicando la línea y el carácter inesperado.
    \item El lexer puede continuar si se desea recuperar el análisis tras un error.
\end{itemize}

\subsection{Errores Sintácticos (Parser con Bison)}

Durante el análisis sintáctico, el parser construido con \textbf{Bison} utiliza reglas gramaticales para validar la estructura del programa.

\begin{itemize}
    \item Se define la función \texttt{yyerror} para reportar errores sintácticos con contexto, como número de línea y descripción.
    \item Bison permite estrategias de recuperación mediante la palabra clave \texttt{error}, que permite continuar el análisis tras ciertos fallos.
    \item Se pueden realizar anotaciones semánticas parciales incluso si hay errores sintácticos, facilitando una mejor recuperación.
\end{itemize}

\subsection{Errores Semánticos (Chequeo con Visitor)}

El chequeo semántico se realiza mediante el patrón \textbf{Visitor}, que recorre el AST y valida reglas del lenguaje como tipos, existencia de variables y estructuras.

\begin{itemize}
    \item Se detectan errores como variables no declaradas, incompatibilidades de tipo, uso incorrecto de métodos o estructuras.
    \item Se registran errores con descripciones claras y ubicación (línea/columna) cuando se dispone de esa información en los nodos del AST.
    \item El recorrido del árbol puede continuar tras un error semántico, acumulando múltiples errores antes de abortar.
\end{itemize}

\subsection{Errores en la Generación de Código (LLVM)}

La fase de generación de código con \textbf{LLVM} puede detectar inconsistencias adicionales antes de producir el binario final.

\begin{itemize}
    \item Se utiliza \texttt{LLVMVerifyModule} para verificar la validez del IR generado.
    \item En caso de error, se imprime una descripción detallada y se detiene la compilación.
    \item Esta verificación previene errores en tiempo de ejecución generados por instrucciones mal formadas o estructuras incorrectas.
\end{itemize}

\subsection{Resumen General}

\begin{itemize}
    \item El compilador implementa una cadena de manejo de errores progresiva, desde el análisis léxico hasta la generación de código.
    \item En cada fase se procura ofrecer diagnósticos útiles, sin abortar inmediatamente, para permitir una mejor experiencia al desarrollador.
    \item Los errores son gestionados de forma localizada, permitiendo que fases posteriores se ejecuten si es razonablemente seguro hacerlo.
\end{itemize}

\end{document}